<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="MJbLog">
<meta property="og:url" content="https:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="MJbLog">
<meta property="article:author" content="MJLUCY">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/"/>





  <title>MJbLog</title>
  








<meta name="generator" content="Hexo 4.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MJbLog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2020/07/28/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/28/promise/" itemprop="url">promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-28T00:00:00+08:00">
                2020-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es6/" itemprop="url" rel="index">
                    <span itemprop="name">es6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Promise概念"><a href="#Promise概念" class="headerlink" title="Promise概念"></a>Promise概念</h4><ul>
<li>什么是Promise</li>
</ul>
<p><strong>Promise</strong> 是一个对象，它代表了一个异步操作的最终完成或者失败。<br>它可以将复杂的异步处理轻松的进行模式化。</p>
<ul>
<li>Promise的优点<br>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了。</li>
</ul>
<h4 id="Promise的基础用法"><a href="#Promise的基础用法" class="headerlink" title="Promise的基础用法"></a>Promise的基础用法</h4><ul>
<li><p>解决回调函数才层层嵌套示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething(function(result) &#123;</span><br><span class="line">  doSomethingElse(result, function(newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function(finalResult) &#123;</span><br><span class="line">      console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>
<p>可以改写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function(result) &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(newResult) &#123;</span><br><span class="line">  return doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(finalResult) &#123;</span><br><span class="line">  console.log(&#39;Got the final result: &#39; + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line"></span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line"></span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
</li>
</ul>
<p><strong>then()</strong> 方法返回一个 Promise<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">具体返回值</a></p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">promise</span><br><span class="line">  .then(function(data) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">  &#125;, function(err) &#123;</span><br><span class="line">    &#x2F;&#x2F; error</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">promise</span><br><span class="line">  .then(function(data) &#123; &#x2F;&#x2F;cb</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(err) &#123;</span><br><span class="line">    &#x2F;&#x2F; error</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。理由是这种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch)。</p>
<h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;···&#125;)</span><br><span class="line">.finally(() &#x3D;&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>
<p>不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<ol>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h4><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 ES2020引入。<h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h4>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4>有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;));</span><br></pre></td></tr></table></figure>
上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/12/18/clone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/clone/" itemprop="url">浅拷贝与深拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T00:00:00+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于引用类型直接复制的效果是地址的复制，只是两个变量指向了同一块内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">var b &#x3D; a;</span><br><span class="line">b.push[4];</span><br><span class="line">console.log(b);&#x2F;&#x2F;[1,2,3,4]</span><br><span class="line">console.log(a);&#x2F;&#x2F;[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>所以有了浅拷贝和深拷贝。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>数组的浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">var b &#x3D; [];</span><br><span class="line">for(var i in a)&#123;</span><br><span class="line">  b[i] &#x3D; a[i];</span><br><span class="line">&#125;</span><br><span class="line">b.push(4);</span><br><span class="line">console.log(a);&#x2F;&#x2F;[1,2,3]</span><br><span class="line">console.log(b);&#x2F;&#x2F;[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>对象的浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">   a: &#39;1&#39;,</span><br><span class="line">   b: &#39;2&#39;,</span><br><span class="line">   c: &#39;3&#39;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line">for(i in obj1&#125;&#123;</span><br><span class="line">  obj2[i] &#x3D; obj1[i];</span><br><span class="line">&#125;</span><br><span class="line">obj2[&#39;d&#39;] &#x3D; 4;</span><br><span class="line">console.log(obj1);&#x2F;&#x2F;&#123;a: 1,b: 2,c: 3&#125;</span><br><span class="line">console.log(obj2);&#x2F;&#x2F;&#123;a: 1,b: 2,c: 3, d:4&#125;</span><br></pre></td></tr></table></figure>

<p>但浅拷贝只能实现一层的拷贝，无法实现更深层次的拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function shallowCopy(obj1,obj2)&#123;</span><br><span class="line">  for(var key in obj1)&#123;</span><br><span class="line">    if(obj1.hasOwnProperty(key))&#123;</span><br><span class="line">       obj2[key] &#x3D; obj1[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  fruits: [&#39;apple&#39;, &#39;peach&#39;],</span><br><span class="line">  num: 100</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line">shallowCopy(obj1,obj2);</span><br><span class="line">obj2.fruits[0] &#x3D; &#39;orange&#39;;</span><br><span class="line">console.log(obj1.fruits[0]); &#x2F;&#x2F;orange</span><br><span class="line">console.log(obj2.fruits[0]); &#x2F;&#x2F;orange</span><br></pre></td></tr></table></figure>
<p>hasOwnProperty方法是为了防止遍历到数组或对象的继承属性</p>
<p>浅拷贝还可以通过Object.assign方法来实现<br><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;a:1,b:&#123;c:2,d:3&#125;&#125;;</span><br><span class="line">var obj2 &#x3D; Object.assign(&#123;&#125;,obj1);</span><br><span class="line">obj2.a &#x3D; 4;</span><br><span class="line">obj2.b.c &#x3D; 5;</span><br><span class="line">console.log(obj1.a);&#x2F;&#x2F;1</span><br><span class="line">console.log(obj2.a);&#x2F;&#x2F;4</span><br><span class="line">console.log(obj1.b.c);&#x2F;&#x2F;5</span><br><span class="line">console.log(obj2.b.c);&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>
<p><code>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</code></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>通过递归调用浅拷贝的方式来实现深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  function deepCopy(obj)&#123;</span><br><span class="line">	var objArray &#x3D; Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">	if(obj &amp;&amp; typeof obj &#x3D;&#x3D;&#x3D; &quot;object&quot;)&#123;</span><br><span class="line">		for(var key in obj)&#123;</span><br><span class="line">		  if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">			  if(obj[key] &amp;&amp; typeof obj[key] &#x3D;&#x3D;&#x3D; &quot;object&quot;)&#123;</span><br><span class="line">			  	objArray[key] &#x3D; deepCopy(obj[key]);</span><br><span class="line">			  &#125;else&#123;</span><br><span class="line">			  	objArray[key] &#x3D; obj[key];</span><br><span class="line">			  &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return objArray;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; &#123; fruits: [&#39;apple&#39;, &#39;peach&#39;], num: 100 &#125;; </span><br><span class="line">var obj2 &#x3D; deepCopy(obj1);</span><br><span class="line">obj2.fruits[0] &#x3D; &#39;orange&#39;; console.log(obj1.fruits[0]); &#x2F;&#x2F;apple </span><br><span class="line">console.log(obj2.fruits[0]); &#x2F;&#x2F;orange</span><br></pre></td></tr></table></figure>
<p>还可以通过Json.parse实现深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;a:1,b:&#123;c:2,d:3&#125;&#125;;</span><br><span class="line">var obj2 &#x3D; JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj2.a &#x3D; 4;</span><br><span class="line">obj2.b.c &#x3D; 5;</span><br><span class="line">console.log(obj1.a);&#x2F;&#x2F;1</span><br><span class="line">console.log(obj2.a);&#x2F;&#x2F;4</span><br><span class="line">console.log(obj1.b.c);&#x2F;&#x2F;2</span><br><span class="line">console.log(obj2.b.c);&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>
<p>原理：用JSON.stringify将对象转成字符串，再用JSON.parse把字符串及解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>
<p>jQuery的extend可以深拷贝也可以浅拷贝</p>
<p>需要注意的是，如果对象比较大，层级也比较多，深复制会带来性能上的问题。在遇到需要采用深复制的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅复制更为常用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/12/18/let/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/let/" itemprop="url">let、const和var的概念与区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T00:00:00+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es6/" itemprop="url" rel="index">
                    <span itemprop="name">es6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用<strong>let</strong>的优点</p>
<ul>
<li>var存在变量提升，let没有<br><code>如果在声明之前访问这些变量，会引发错误。而从作用域顶部到声明变量语句之前的这个区域，被称为临时死区</code></li>
<li>禁止重声明，用let声明已存在的标识符会抛出错误</li>
<li>不会成为window对象的属性<br><code>对var声明的变量来说，如果处于全局作用域，它们会自动成为window对象的属性。这意味着用var很可能无意中覆盖一个已经存在的全局变量。如果使用let或const声明的变量，不会成为window对象的属性</code></li>
<li>循环绑定<br><code>let声明每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化。</code></li>
</ul>
<p><strong>const</strong>也一样没有变量提升、存在临时死区，禁止重声明，不会成为window对象的属性。<br>const与let声明最大的不同之处在于，const声明的常量无法再赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let num1 &#x3D; 10;</span><br><span class="line">num1&#x3D; 20;</span><br><span class="line"></span><br><span class="line">const num2 &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">num2 &#x3D; 20;</span><br></pre></td></tr></table></figure>
<p>const声明不允许修改绑定，但允许修改值。这也就意味着用const声明对象后，可以修改该对象的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">    name: &#39;huochai&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;可以修改对象属性的值</span><br><span class="line">person.name &#x3D; &#39;match&#39;;</span><br><span class="line">&#x2F;&#x2F;Object &#123;name: &quot;match&quot;&#125;</span><br><span class="line">console.log(person);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抛出语法错误</span><br><span class="line">&#x2F;&#x2F;Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">person &#x3D; &#123;</span><br><span class="line">    name: &#39;match&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>var声明会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getValue(condition)&#123;</span><br><span class="line">    if(condition)&#123;</span><br><span class="line">        var value &#x3D; &#39;blue&#39;;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">　　　　 &#x2F;&#x2F;此处可访问变量value，值为undefined</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">　　　　&#x2F;&#x2F;此处可访问变量value，值为undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有javascript开发经验，可能会认为只有condition为true时，才会创建变量value</p>
<p>但实际上，在预编译阶段，javascript引擎会将上面的函数修改成下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getValue(condition)&#123;</span><br><span class="line">    var value;</span><br><span class="line">    if(condition)&#123;</span><br><span class="line">        value &#x3D; &#39;blue&#39;;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getValue(condition)&#123;</span><br><span class="line">    if(condition)&#123;</span><br><span class="line">        let value &#x3D; &#39;blue&#39;;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">         &#x2F;&#x2F;变量value在此处不存在</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;变量value在此处不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h5><p>与var不同，let和const声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会引发错误。而从作用域顶部到声明变量语句之前的这个区域，被称为临时死区(temporal dead zone)，简称为TDZ</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;undefined</span><br><span class="line">    console.log(typeof value);</span><br><span class="line">    var value &#x3D; &quot;blue&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;Uncaught ReferenceError: value is not defined</span><br><span class="line">    console.log(typeof value);</span><br><span class="line">    let value &#x3D; &quot;blue&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，在let或const声明的作用域之外使用该变量就不会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;undefined</span><br><span class="line">console.log(typeof value);</span><br><span class="line">if(true)&#123;</span><br><span class="line">    let value &#x3D; &quot;blue&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F;抛出语法错误</span><br><span class="line">&#x2F;&#x2F;Uncaught SyntaxError: Identifier &#39;count&#39; has already been declared</span><br><span class="line">let count &#x3D; 40;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30;</span><br><span class="line">var count &#x3D; 40;</span><br><span class="line">console.log(count);&#x2F;&#x2F;40</span><br></pre></td></tr></table></figure>
<h4 id="不会成为window对象的属性"><a href="#不会成为window对象的属性" class="headerlink" title="不会成为window对象的属性"></a>不会成为window对象的属性</h4><p>对var声明的变量来说，如果处于全局作用域，它们会自动成为window对象的属性。这意味着用var很可能无意中覆盖一个已经存在的全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;function RegExp() &#123; [native code] &#125;</span><br><span class="line">console.log(RegExp);</span><br><span class="line">var RegExp &#x3D; &quot;hello&quot;;</span><br><span class="line">console.log(RegExp);&#x2F;&#x2F;&#39;hello&#39;</span><br><span class="line">console.log(window.RegExp);&#x2F;&#x2F;&#39;hello&#39;</span><br></pre></td></tr></table></figure>
<p>如果使用let或const声明的变量，不会成为window对象的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let RegExp &#x3D; &quot;hello&quot;;</span><br><span class="line">console.log(RegExp);&#x2F;&#x2F;&#39;hello&#39;</span><br><span class="line">console.log(window.RegExp);&#x2F;&#x2F;function RegExp() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果希望在window对象下定义变量，要使用var声明。如果不希望，则使得let或const</p>
<h4 id="循环绑定"><a href="#循环绑定" class="headerlink" title="循环绑定"></a>循环绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line">for(var i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;输出10次10</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，预期的结果是输出数字0-9，但它却一连串输出了10次10，这是因为循环里的每次迭代同时共享着变量i，循环内部创建的函数全都保留了对相同变量的引用，循环结束时变量i的值为10，所以每次调用console.log(i)时就会输出10.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line">for(let i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;0</span><br><span class="line">        &#x2F;&#x2F;1</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">        &#x2F;&#x2F;9</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每次循环时let声明都会创建一个新变量i，并将其初始化为i的当前值，所以循环内部创建的每个函数都能得到属性它们自己的i的副本</p>
<p>对于for-in循环和for-of循环来说也是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line">obj &#x3D; &#123;</span><br><span class="line">    a:true,</span><br><span class="line">    b:true,</span><br><span class="line">    c:true</span><br><span class="line">&#125;</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;a</span><br><span class="line">        &#x2F;&#x2F;b</span><br><span class="line">        &#x2F;&#x2F;c</span><br><span class="line">        console.log(key);</span><br><span class="line">        &#x2F;&#x2F;如果是for(var key in obj)会输出c c c</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于const声明来说，由于其无法改变变量的值，所以无法使用普通的for循环</p>
<p>由于for-in循环中每次迭代不会修改已有绑定，而是创建一个新绑定，所以在for-in循环中可以使用const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var funcs &#x3D; [];</span><br><span class="line">obj &#x3D; &#123;</span><br><span class="line">    a:true,</span><br><span class="line">    b:true,</span><br><span class="line">    c:true</span><br><span class="line">&#125;</span><br><span class="line">for(const key in obj)&#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;a</span><br><span class="line">        &#x2F;&#x2F;b</span><br><span class="line">        &#x2F;&#x2F;c</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/12/18/deconstruct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/18/deconstruct/" itemprop="url">解构赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-18T00:00:00+08:00">
                2019-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es6/" itemprop="url" rel="index">
                    <span itemprop="name">es6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在ES5中，从对象和数组中获取特定数据并赋值给变量，有许多看起来同质化的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let options &#x3D; &#123;</span><br><span class="line">    repeat: true,</span><br><span class="line">    save: false</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 从对象中提取数据</span><br><span class="line">let repeat &#x3D; options.repeat,</span><br><span class="line">save &#x3D; options.save;</span><br></pre></td></tr></table></figure>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; type, name &#125; &#x3D; node;</span><br><span class="line">console.log(type); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>如果不是用在声明中，用在赋值中需要加小括号，因为语法规定，代码块语句不允许出现在赋值语句左侧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;,</span><br><span class="line">type &#x3D; &quot;Literal&quot;,</span><br><span class="line">name &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; 使用解构来分配不同的值</span><br><span class="line">(&#123; type, name &#125; &#x3D; node);</span><br><span class="line">console.log(type); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值过程。<br>解构赋值表达式的值与表达式右侧(也就是=右侧)的值相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;,</span><br><span class="line">type &#x3D; &quot;Literal&quot;,</span><br><span class="line">name &#x3D; 5;</span><br><span class="line">function outputInfo(value) &#123;</span><br><span class="line">    console.log(value &#x3D;&#x3D;&#x3D; node); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br><span class="line">outputInfo(&#123; type, name &#125; &#x3D; node);</span><br><span class="line">console.log(type); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>调用outputlnfo()函数时传入了一个解构表达式，由于JS表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type和name被重新赋值，最终将node传入outputlnfo()函数</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; type, name, value &#125; &#x3D; node;</span><br><span class="line">console.log(type); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">console.log(value); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<p>当指定的属性不存在时，可以随意定义一个默认值，在属性名称后添加一个等号(=)和相应的默认值即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; type, name, value &#x3D; true &#125; &#x3D; node;</span><br><span class="line">console.log(type); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line">console.log(value); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>在此示例中，为变量value设置了默认值true，只有当node上没有该属性或者该属性值为undefined时该值才生效。此处没有node.value属性，因为value使用了预设的默认值</p>
<h4 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; type: localType, name: localName &#125; &#x3D; node;</span><br><span class="line">console.log(localType); &#x2F;&#x2F; &quot;Identifier&quot;</span><br><span class="line">console.log(localName); &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>这段代码使用了解构赋值来声明变量localType和localName，这两个变量分别包含node.type和node.name属性的值。</p>
<h4 id="嵌套对象解构"><a href="#嵌套对象解构" class="headerlink" title="嵌套对象解构"></a>嵌套对象解构</h4><p>解构嵌套对象仍然与对象字面量的语法相似，可以将对象拆解以获取想要的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: 1,</span><br><span class="line">            column: 1</span><br><span class="line">        &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">        line: 1,</span><br><span class="line">        column: 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; loc: &#123; start &#125;&#125; &#x3D; node;</span><br><span class="line">console.log(start.line); &#x2F;&#x2F; 1</span><br><span class="line">console.log(start.column); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">let [ firstColor, secondColor ] &#x3D; colors;</span><br><span class="line">console.log(firstColor); &#x2F;&#x2F; &quot;red&quot;</span><br><span class="line">console.log(secondColor); &#x2F;&#x2F; &quot;green&quot;</span><br></pre></td></tr></table></figure>
<p>也可以直接省略元素，只为感兴趣的元素提供变量名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">let [ , , thirdColor ] &#x3D; colors;</span><br><span class="line">console.log(thirdColor); &#x2F;&#x2F; &quot;blue&quot;</span><br></pre></td></tr></table></figure>
<p>用于直接赋值时，不需要加小括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</span><br><span class="line">firstColor &#x3D; &quot;black&quot;,</span><br><span class="line">secondColor &#x3D; &quot;purple&quot;;</span><br><span class="line">[ firstColor, secondColor ] &#x3D; colors;</span><br><span class="line">console.log(firstColor); &#x2F;&#x2F; &quot;red&quot;</span><br><span class="line">console.log(secondColor); &#x2F;&#x2F; &quot;green&quot;</span><br></pre></td></tr></table></figure>
<h4 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h4><p>可以用数组解构的方法很方便的实现变量交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 ES6 中互换值</span><br><span class="line">let a &#x3D; 1,</span><br><span class="line">    b &#x3D; 2;</span><br><span class="line">[ a, b ] &#x3D; [ b, a ];</span><br><span class="line">console.log(a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(b); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>也可以在数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为undefined时使用默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot; ];</span><br><span class="line">let [ firstColor, secondColor &#x3D; &quot;green&quot; ] &#x3D; colors;</span><br><span class="line">console.log(firstColor); &#x2F;&#x2F; &quot;red&quot;</span><br><span class="line">console.log(secondColor); &#x2F;&#x2F; &quot;green&quot;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];</span><br><span class="line">&#x2F;&#x2F; 随后</span><br><span class="line">let [ firstColor, [ secondColor ] ] &#x3D; colors;</span><br><span class="line">console.log(firstColor); &#x2F;&#x2F; &quot;red&quot;</span><br><span class="line">console.log(secondColor); &#x2F;&#x2F; &quot;green&quot;</span><br></pre></td></tr></table></figure>
<h4 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h4><p>在数组中，可以通过…语法将数组中的其余元素赋值给一个特定的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">let [ firstColor, ...restColors ] &#x3D; colors;</span><br><span class="line">console.log(firstColor); &#x2F;&#x2F; &quot;red&quot;</span><br><span class="line">console.log(restColors.length); &#x2F;&#x2F; 2</span><br><span class="line">console.log(restColors[0]); &#x2F;&#x2F; &quot;green&quot;</span><br><span class="line">console.log(restColors[1]); &#x2F;&#x2F; &quot;blue&quot;</span><br></pre></td></tr></table></figure>
<p>#####数组赋值<br>在ES5中，开发者们经常使用concat()方法来克隆数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 ES5 中克隆数组</span><br><span class="line">var colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">var clonedColors &#x3D; colors.concat();</span><br><span class="line">console.log(clonedColors); &#x2F;&#x2F;&quot;[red,green,blue]&quot;</span><br></pre></td></tr></table></figure>
<p>在ES6中，可以通过不定元素的语法来实现相同的目标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</span><br><span class="line">let [ ...clonedColors ] &#x3D; colors;</span><br><span class="line">console.log(clonedColors); &#x2F;&#x2F;&quot;[red,green,blue]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let node &#x3D; &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;foo&quot;,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: 1,</span><br><span class="line">            column: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line: 1,</span><br><span class="line">            column: 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    range: [0, 3]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;</span><br><span class="line">    loc: &#123; start &#125;,</span><br><span class="line">    range: [ startIndex ]</span><br><span class="line">&#125; &#x3D; node;</span><br><span class="line">console.log(start.line); &#x2F;&#x2F; 1</span><br><span class="line">console.log(start.column); &#x2F;&#x2F; 1</span><br><span class="line">console.log(startIndex); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<h3 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h3><p>普通写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; options 上的属性表示附加参数</span><br><span class="line">function setCookie(name, value, options) &#123;</span><br><span class="line">    options &#x3D; options || &#123;&#125;;</span><br><span class="line">    let secure &#x3D; options.secure,</span><br><span class="line">        path &#x3D; options.path,</span><br><span class="line">        domain &#x3D; options.domain,</span><br><span class="line">        expires &#x3D; options.expires;</span><br><span class="line">        &#x2F;&#x2F; 设置 cookie 的代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 第三个参数映射到 options</span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</span><br><span class="line">    secure: true,</span><br><span class="line">    expires: 60000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用解构参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123;</span><br><span class="line">&#x2F;&#x2F; 设置 cookie 的代码</span><br><span class="line">&#125;</span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</span><br><span class="line">    secure: true,</span><br><span class="line">    expires: 60000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>解构参数需要使用对象或数组解构模式代替命名参数。如果调用函数时不提供被解构的参数会导致程序抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 出错！</span><br><span class="line">setCookie(&quot;type&quot;, &quot;js&quot;);</span><br></pre></td></tr></table></figure>
<p>因为当调用setCookie()函数时，JS引擎实际上做了以下这些事情</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, options) &#123;</span><br><span class="line">    let &#123; secure, path, domain, expires &#125; &#x3D; options;</span><br><span class="line">    &#x2F;&#x2F; 设置 cookie 的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果解构赋值表达式的右值为null或undefined，则程序会报错。</p>
<p>如果解构参数是必需的，大可忽略掉这些问题；但如果希望将解构参数定义为可选的，那么就必须为其提供默认值来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中为解构参数添加了一个新对象作为默认值，secure、path、domain及expires这些变量的值全部为undefined，这样即使在调用setCookie()时未传递第3个参数，程序也不会报错</p>
<h4 id="默认值-2"><a href="#默认值-2" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name, value,</span><br><span class="line">    &#123;</span><br><span class="line">        secure &#x3D; false,</span><br><span class="line">        path &#x3D; &quot;&#x2F;&quot;,</span><br><span class="line">        domain &#x3D; &quot;example.com&quot;,</span><br><span class="line">        expires &#x3D; new Date(Date.now() + 360000000)</span><br><span class="line">    &#125; &#x3D; &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将默认值放到setCookieDefaults对象中，在解构参数中可以直接使用这个对象来为每一个绑定设置默认参数。如果要改变默认值，可以立即在setCookieDefaults中修改，改变的数据将自动同步到所有出现过的地方。</p>
<h3 id="其他解构"><a href="#其他解构" class="headerlink" title="其他解构"></a>其他解构</h3><h4 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h4><p>字符串也可以解构赋值。这是因为，字符串被转换成了一个类似数组的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] &#x3D; &#39;hello&#39;;</span><br><span class="line">console.log(a);&#x2F;&#x2F;&quot;h&quot;</span><br><span class="line">console.log(b);&#x2F;&#x2F;&quot;e&quot;</span><br><span class="line">console.log(c);&#x2F;&#x2F;&quot;l&quot;</span><br><span class="line">console.log(d);&#x2F;&#x2F;&quot;l&quot;</span><br><span class="line">console.log(e);&#x2F;&#x2F;&quot;o&quot;</span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;length&#125; &#x3D; &#39;hello&#39;;</span><br><span class="line">console.log(length);&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<h4 id="数值和布尔值解构"><a href="#数值和布尔值解构" class="headerlink" title="数值和布尔值解构"></a>数值和布尔值解构</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;toString:s1&#125; &#x3D; 123;</span><br><span class="line">console.log(s1 &#x3D;&#x3D;&#x3D; Number.prototype.toString);&#x2F;&#x2F;true</span><br><span class="line">let &#123;toString:s2&#125; &#x3D; true;</span><br><span class="line">console.log(s2 &#x3D;&#x3D;&#x3D; Boolean.prototype.toString);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; prop: x &#125; &#x3D; undefined; &#x2F;&#x2F; TypeError</span><br><span class="line">let &#123; prop: y &#125; &#x3D; null; &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/12/17/rem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/rem/" itemprop="url">rem和em</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-17T00:00:00+08:00">
                2019-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jianshu.com/p/a0bdd3e9133d" target="_blank" rel="noopener">响应式Web设计—px-em-rem三者区别及rem的使用</a><br>在css中单位长度用的最多的是px、em、rem，这三个的区别是：</p>
<ul>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小的，一般都是以<code>&lt;body&gt;</code>的<code>font-size</code>为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而Rem是相对于根元素<code>&lt;html&gt;</code>，这样就意味着，我们只需要在根元素确定一个参考值。</li>
</ul>
<p>总之：对于em和rem的区别一句话概括：<br><code>em相对于父元素，rem相对于根元素。</code></p>
<p><a href="https://blog.csdn.net/lsx19981201/article/details/86608147" target="_blank" rel="noopener">移动端自适应所有屏幕的动态方法</a></p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-widht,initial-scale=1.0,user-scalable=1.0,maximum-scale=1.0,minimum-scale=1.0&quot;&gt;</code></p>
<p>明白一个浏览器默认行为。<br>试想，浏览器如果把电脑端的980px的网页展现在宽度为750px的iphone6手机屏上，势必会放不下，手机端横向会出现滚动条，怎么阻止这种情况呢，很简单，浏览器默认一个虚拟窗口，不同浏览器有不同的虚拟窗口宽度的默认值如：safari iphone：980px;opera:850px; Andriod webkit:800px;IE:974px;然后会把这个980px虚拟窗口装进宽度为750px的iphone6中，当然这样的话必须缩放，这就是为什么在手机中展现电脑端页面没有出现横向滚动条，而且字迹明显变小的原因。</p>
<p>meta标签中，width有两个含义，第一、width为phys.width，第二，width也为虚拟窗口的width。这样就会有两个结果：</p>
<ol>
<li><p>此时的iPhone6的phys.width也变成了css-width即375px，我们可以通过document.documentElement.clientWidth获取得到此时phys.width确实为375px。</p>
</li>
<li><p>如你设计的是375px的手机端页面，此时的虚拟窗口的宽度也为375px，再装进phys.width为375px的手机，当然如设计稿一样的效果，不会缩放，也不会出现横向滚动条。</p>
</li>
</ol>
<p>user-scalable=no就一定可以保证页面不可以缩放吗？NO，有些浏览器不吃这一套，还有一招就是minimum-scale=1.0, maximum-scale=1.0 最大与最小缩放比例都设为1.0就可以了</p>
<p>要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 <code>width=device-width</code>，也可以设置 <code>initial-scale=1</code>，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 <code>initial-scale=1</code> 解决了 iphone、ipad的毛病，<code>width=device-width</code>则解决了IE的毛病：</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code><br><a href="https://blog.csdn.net/u012402190/article/details/70172371" target="_blank" rel="noopener">meta name=”viewport” content=”width=device-width,initial-scale=1.0” 解释</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/12/15/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/15/http/" itemprop="url">HTTP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-15T00:00:00+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zhuanlan.zhihu.com/p/24913080?utm_source=qq&utm_medium=social&utm_oi=667009035568680960" target="_blank" rel="noopener">网络基础知识之 HTTP 协议</a><br>首先从一个问题入手，当我们在浏览器输入url时，浏览器做了哪些事情。<br>1.首先Chrome搜索自身的DNS缓存。<br>2.读取硬盘中的host文件，里面记录着域名到ip地址的映射关系(如果1没有找到)<br>3.浏览器向宽带运营服务商或域名服务器发起DNS解析请求(如果12都没有找到)<br>4.拿到ip地址后，浏览器就向该ip地址所在服务器建立TCP连接(三次握手)<br>5.建立连接后，浏览器向服务器发起http请求(比如访问百度首页，就向服务器发起HTTP中的get请求)<br>6.服务器收到请求后，根据路径参数，经过后台一些处理后，把处理的结果返回给浏览器(如果是百度首页，就把完整的HTML页面代码返回给浏览器)<br>7.浏览器拿到完整的HTML页面代码，内核和js引擎就会解析和渲染这个页面，里面的js,css,图片等静态资源也通过一个个HTTP请求进行加载<br>8.浏览器根据拿到的资源对页面进行渲染，最终把完整页面呈现给用户<br>9.如果浏览器没有后续请求，就会跟服务器端发起TCP断开(四次挥手)</p>
<p>补充:HTML页面加载和解析流程</p>
<ol>
<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。</li>
<li>浏览器开始载入html代码，发现<code>&lt;head&gt;</code>标签内有一个<code>&lt;link&gt;</code>标签引用外部CSS文件。</li>
<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件。</li>
<li>浏览器继续载入html中<code>&lt;body&gt;</code>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。</li>
<li>浏览器在代码中发现一个<code>&lt;img</code>&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。</li>
<li>浏览器发现了一个包含一行Javascript代码的<code>&lt;script&gt;</code>标签，赶快运行它。</li>
<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<code>&lt;style&gt;(style.display=”none”)</code>  杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。</li>
<li>终于等到了<code>&lt;/html&gt;</code>的到来，浏览器泪流满面……</li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。</li>
<li>浏览器召集了在座的各位<code>&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 </li>
</ol>
<h3 id="HTTP特性："><a href="#HTTP特性：" class="headerlink" title="HTTP特性："></a>HTTP特性：</h3><ul>
<li>HTTP是无连接无状态的</li>
<li>HTTP一般构建于TCP/IP协议之上，默认端口号是80<br>补充:<br>一. 无连接<br>  1.每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的<br>  2.无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接<br>二. 无状态<br>   1.协议对于事务处理没有记忆能力<br>   2.对同一个url请求没有上下文关系<br>   3.每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况<br>   4.服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器<br>三. TCP<br>TCP的传输数据的核心是在于将数据分为若干段并将每段数据按顺序标记。标记后的顺序可以以不同的顺序被另一方接收并集成回完整的数据。计算机对每一段数据的成功接收都会做出相应，确保所有数据的完整性。</li>
</ul>
<p>HTTP可以分为两个部分: 请求和响应</p>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求:"></a>HTTP请求:</h3><p>HTTP定义了与服务器交互的四种方式，分别是GET,POST,PUT,DELETE。可以这么认为：一个URL地址对应一个网络上的资源，而HTTP中的get,post,put,delete对应着对这个资源的查询，修改，增添，删除4个操作</p>
<p>HTTP请求由3个部分组成，分别是：状态行，请求头，请求正文。<br>GET请求：<br><img src="/images/pic1.jpg" alt="图片1"></p>
<ul>
<li>状态行由请求方式、路径和协议构成，各元素间用空格分隔。比如：</li>
<li>GET、/books/?sex=man&amp;name=Professional、HTTP/1.1<br>请求头提供一些参数比如:Cookie, 用户代理信息，主机名等等</li>
<li>请求正文放一些发送的数据，一般get请求会将参数放在url中，post请求把参数放在请求正文中。请求正文可以传一些json数据或字符串等。</li>
</ul>
<p>get一般用于信息获取，它不会产生副作用，仅仅是获取资源信息，而post请求表示可能会修改服务器上的资源。<br><img src="/images/pic2.jpg" alt="图片2"></p>
<p>GET请求和POST请求的区别<br>1.请求参数位置不同，get在url中，而post在请求体中(但这只是一种约定，get请求中出现body也是被允许的)<br>2.由于url最大字符长度限制，导致get请求中参数数量是有限的<br>3.在涉及安全的请求比如:登录请求需要提交表单，而get请求一般用来获取静态资源<br>4.get请求可以被缓存，可以被存为书签，post请求可以被缓存，但不能被存为书签<br>补充：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a><br>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p>
<p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p>
<p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>GET和POST还有一个重大区别，简单的说：</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。<br>长的说：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。<h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3>和HTTP请求相似，也由三部分构成：状态行、响应头、响应正文<br><img src="/images/pic3.jpg" alt="图片3"><br>响应中包含一个状态码，用来表示服务器对客户端响应的结果<br>常见状态码：<br>200 OK 客户端请求成功。<br>301 Moved Permanently 请求永久重定向。<br>302 Moved Temporarily 请求临时重定向。<br>304 Not Modified 文件未修改，可以直接使用缓存的文件。<br>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized 请求未经授权，无法访问。<br>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。<br>404 Not Found 请求的资源不存在，比如输入了错误的URL。<br>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。<br>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP响应码</a></li>
</ol>
<p>一个完整的流程一般是这样的：<br>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口(默认是80端口)的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器发送一个状态行，比如”HTTP/1.1 200 OK”，和响应的消息，消息的消息体可能是请求的文件、错误消息、或其他一些信息。</p>
<h3 id="HTTP头信息"><a href="#HTTP头信息" class="headerlink" title="HTTP头信息"></a>HTTP头信息</h3><p>以请求百度首页为例</p>
<h4 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h4><p>以百度首页为例<br><img src="/images/pic4.jpg" alt="图片4"></p>
<ul>
<li>Accept: 指定客户端能接受的内容类型，如常见的text/html等，最后返回的百度首页也是个HTML文件</li>
<li>Accept-Encoding: 表示浏览器有能力解码的编码类型</li>
<li>Cache-Control: 指定请求和响应遵循的缓存机制(这里表示不需要缓存)</li>
<li>Connection: 表示是否需要持久连接</li>
<li>Cookie: 用于会话追踪</li>
<li>Host: 请求的服务器网址</li>
<li>User-Agent: 用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户端使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</li>
</ul>
<p>另外一些常见请求头</p>
<ul>
<li>Content-Length: 请求的内容长度</li>
<li>Referer: 先前访问的网页地址，当前请求网页紧随其后，说明你是先前是从哪个网址点击访问到该页面的，如果没有则不填。</li>
<li>Content-Type: 内容类型，get请求无该字段，post请求中常见的有application/x-www-form-urlencoded为普通表单提交，还有文件上传为multipart/form-data</li>
</ul>
<h4 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h4><p>还是以百度举例<br><img src="/images/pic5.jpg" alt="图片5"></p>
<p>前一个是自定义字段，HTTP 请求头中的字段是可以自定义的。<br><a href="https://blog.csdn.net/qq_42695697/article/details/84553669" target="_blank" rel="noopener">http请求头添加自定义参数</a><br>Connection, Content-Encoding, Content-Type 和请求头的内容差不多，不再赘述。</p>
<ul>
<li>Date: 原始服务器消息发出的时间</li>
<li>Last-Modified: 请求资源的最后修改时间</li>
<li>Expires: 响应过期的日期和时间，如果下次访问在时间允许的范围内，可以不用重新请求，直接访问缓存。</li>
<li>Set-Cookie: 设置Http Cookie，下次浏览器再次访问的时候会带上这个 Cookie 值。</li>
<li>Server：服务器软件名称，常见的有 Apache 和 Nginx。</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="会话追踪"><a href="#会话追踪" class="headerlink" title="会话追踪"></a>会话追踪</h4><ul>
<li>会话：客户端向服务器端发起请求到服务端响应客户端请求的全过程。</li>
<li>会话跟踪：会话追踪指的是服务器对用户响应的监视。</li>
</ul>
<p>为什么需要会话跟踪：</p>
<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。</p>
<p>比如你在访问淘宝登录之后会持续追踪你的会话，记录你的购物车记录等等。</p>
<p>会话跟踪常用方法：<br>    会话：客户端向服务器端发起请求到服务端响应客户端请求的全过程。<br>    会话跟踪：会话追踪指的是服务器对用户响应的监视。</p>
<p>为什么需要会话跟踪：</p>
<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。</p>
<p>比如你在访问淘宝登录之后会持续追踪你的会话，记录你的购物车记录等等。</p>
<p>会话跟踪常用方法：</p>
<ul>
<li>URL 重写：URL 重写技术就是在 URL 结尾添加一个附加数据以标识该会话，把会话 ID 通过 URL 的信息传递过去，以便在服务器进行识别不同的用户。</li>
<li>隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示。</li>
<li>Cookie：Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送给服务器端，进而进行用户的识别，对于客户端的每次请求，服务器都会将 Cookie 发送到客户端，客户端保存下来，以便下次使用。<blockquote>
<p>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。<br>另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。<br>Cookie 是可以被禁止的，当你打开 Chrome，在设置里面关闭 Cookie，那么你将再也无法登录淘宝页面。</p>
</blockquote>
</li>
<li>Session：在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。<blockquote>
<p>每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。<br>Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。</p>
</blockquote>
</li>
</ul>
<p>补充：</p>
<h4 id="Cookie、Session、LocalStorage"><a href="#Cookie、Session、LocalStorage" class="headerlink" title="Cookie、Session、LocalStorage"></a>Cookie、Session、LocalStorage</h4><p><a href="https://juejin.im/post/5bbc47a15188255c9e02edbd" target="_blank" rel="noopener">cookie和session</a><br><a href="https://www.cnblogs.com/cencenyue/p/7604651.html" target="_blank" rel="noopener">浅谈session,cookie,sessionStorage,localStorage的区别及应用场景</a></p>
<p>Cookie机制<br><img src="/images/pic6.png" alt="图片6"><br>Session机制</p>
<blockquote>
<p>session是一种服务度机制，类似散列表结构来存储用户数据<br>浏览器第一次向客户端发送请求时，服务器会自动生成一个session和sessionid<br>sessionid唯一标识这个session<br>服务器响应时把sessionid发送给浏览器<br>浏览器第二次向服务器发送请求时就会携带这个sessionid<br>服务器通过这个id找到对应的session获取用户数据</p>
</blockquote>
<p>session和cookie区别</p>
<ul>
<li>session保存在服务器，cookie保存在客户端</li>
<li>session中保存的时对象，cookie保存的是字符串</li>
<li>session不能区分路径，同一个用户访问一个网站期间，所有的session在任何一个地方都可以访问</li>
<li>cookie如果设置路径，则在某些地方不能访问</li>
<li>session需要借助cookie才能正常工作，如果禁用cookie,session则失效</li>
<li>客户端会在发送请求的时候，自动将本地存活的cookie封装在信息头发送给服务器</li>
</ul>
<p>session和cookie应用场景<br>session上下文机制，针对每一个用户，通过sessionid来区分不同客户。session是以cookie或url重写为基础的，默认使用cookie实现，系统会创造一个名为jsessionid的输出cookie。重要状态走session,不重要走cookie,登陆信息用session，购物车用cookie。</p>
<blockquote>
<p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。发访问量极高的网站，是不太可能运用Session来追踪客户会话的。Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。</p>
</blockquote>
<p>做购物车的时候，有很多数据是要长期保存在客户端的.<br>有三种简单的办法可以实现：<br>1.保存在session里,缺点是占用服务器资源<br>2.保存在cookie里,缺点是不安全.<br>3.保存在数据库里，缺点是存取数据太慢.<br>因为购物车一般没什么机密信息,所以适合用cookie来做.</p>
<h4 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h4><p>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p>
<p>WebStorage两个主要目标:<br>1.提供一种在cookie之外存储会话数据的路径。<br>2.提供一种存储大量可以跨会话存在的数据的机制。</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。</p>
<p>WebStorage的优点：</p>
<ol>
<li>存储空间更大：cookie为4KB，而WebStorage是5MB；</li>
<li>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；</li>
<li>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；</li>
<li>快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；</li>
<li>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；</li>
<li>WebStorage提供了一些方法，数据操作比cookie方便<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　　　   setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class="line"></span><br><span class="line">      　　 getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class="line"></span><br><span class="line">        　　removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class="line"></span><br><span class="line">        　　clear () ——  删除所有的数据</span><br><span class="line"></span><br><span class="line">        　　key (index) —— 获取某个索引的key</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>
<p>在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p>
<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 “Connection: close” 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>
<p>由于 HTTP 1.0 没有官方的 Keep-Alive 规范，并且也已经基本被淘汰。</p>
<p>HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。HTTP 是一个无状态无连接的协议，那么这是不是与 Keep-Alive 冲突？</p>
<ul>
<li>Keep-Alive 与无连接的特性冲突，而对于无状态的特性两者并无矛盾，HTTP 无状态无连接是在 1.0 版本中就规定的，而 Keep-Alive 则是在 1.1 版本中才被添加入规范。 </li>
<li>无连接的意思是限制每个连接只有一个请求的意思，在服务器处理完客户的请求，并收到客户的反应，即断开。通过这种方式可以节省传输时间。 </li>
<li>Keep-Alive 确实破坏了这一特性，而无状态协议则意味着每个请求都是独立的，互不干扰的，互相没有记忆的。所以才需要有会话跟踪这种机制来识别用户。</li>
</ul>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案：</p>
<ol>
<li>HTTP 条件 GET 使用时机：客户端之前已经访问过某网站，并打算再次访问该站点。</li>
<li>HTTP 条件 GET 使用的方法：客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。<br>强缓存和协商缓存<br><a href="https://jayzangwill.github.io/blog/2019/02/07/cache/" target="_blank" rel="noopener">扒一扒浏览器缓存机制</a><br><a href="https://segmentfault.com/a/1190000017962411" target="_blank" rel="noopener">彻底搞懂浏览器缓存机制</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/02/05/arraylike/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/05/arraylike/" itemprop="url">类数组与数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+08:00">
                2019-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>数组和类数组对象有什么区别<br>数组和类数组对象都可以用索引访问，并具有length属性，不同是类数组不能调用数组的方法。</p>
</li>
<li><p>什么是类数组对象</p>
</li>
</ul>
<ol>
<li>拥有length属性</li>
<li>元素保存在对象中，可以通过索引访问</li>
<li>但是没有数组的其他方法，例如：push、slice、indexOf等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    0: &#39;Java&#39;,</span><br><span class="line">    1: &#39;Python&#39;,</span><br><span class="line">    2: &#39;JavaScript&#39;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 因为foo对象本身并没有slice方法，所以通过call调用</span><br><span class="line">var arr &#x3D; Array.prototype.slice.call(foo); &#x2F;&#x2F; [‘Java’,’Python’,’JavaScript’]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>常见的类数组对象<br>javascript中常见的类数组有arguments对象和DOM方法的返回结果。<br>比如 document.getElementsByTagName()。</p>
</li>
<li><p>类数组转化为数组<br>Array.prototype.slice.call()<br>Array.from()</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/02/05/new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/05/new/" itemprop="url">new的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+08:00">
                2019-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; function(name)&#123;</span><br><span class="line">   this.name  &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHello &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;hello &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&#39;HANMEI&#39;);</span><br><span class="line">p1.sayHello();</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个类的实例<br>创建一个空对象obj，把这个空对象的<code>_proto_</code>设置为<code>Person.prototype</code></li>
<li>初始化实例<br>构造函数Person被传入参数并调用，关键字this指向该obj</li>
<li>返回实例obj</li>
</ol>
<p>new的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function New(F)&#123;</span><br><span class="line">    var obj &#x3D; &#123;&#39;__proto__&#39;: F.prototype&#125;;  &#x2F;*第一步*&#x2F;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        F.apply(obj, arguments);           &#x2F;*第二步*&#x2F;</span><br><span class="line">        return obj;                        &#x2F;*第三步*&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/02/05/apply/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/05/apply/" itemprop="url">apply、call、bind</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+08:00">
                2019-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>所有函数都有apply和call方法，他们作用相同只是传参形式不同</p>
<ul>
<li>apply()<br>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name : &#39;linxin&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(firstName, lastName)&#123;</span><br><span class="line">    console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(obj, [&#39;A&#39;, &#39;B&#39;]);    &#x2F;&#x2F; A linxin B</span><br></pre></td></tr></table></figure>
可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。</li>
<li>call( )</li>
</ul>
<p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name: &#39;linxin&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(firstName, lastName) &#123;</span><br><span class="line">    console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, &#39;C&#39;, &#39;D&#39;);       &#x2F;&#x2F; C linxin D</span><br></pre></td></tr></table></figure>
<p>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。</p>
<p>对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。</p>
<ul>
<li>apply和call的用法</li>
</ul>
<ol>
<li>改变 this 指向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name: &#39;linxin&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj);       &#x2F;&#x2F; linxin</span><br></pre></td></tr></table></figure>
我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    console.log(obj.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>借用别的对象的方法</li>
</ol>
<p>先看例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person1  &#x3D; function () &#123;</span><br><span class="line">    this.name &#x3D; &#39;linxin&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var Person2 &#x3D; function () &#123;</span><br><span class="line">    this.getname &#x3D; function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    Person1.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person2();</span><br><span class="line">person.getname();       &#x2F;&#x2F; linxin</span><br></pre></td></tr></table></figure>
<p>从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。<br>3. 调用函数</p>
<p>apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    console.log(&#39;linxin&#39;);</span><br><span class="line">&#125;</span><br><span class="line">func.call();            &#x2F;&#x2F; linxin</span><br></pre></td></tr></table></figure>
<ul>
<li>bind()</li>
</ul>
<ol>
<li>bind 发返回值是函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name: &#39;linxin&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func1 &#x3D; func.bind(obj);</span><br><span class="line">func1();                        &#x2F;&#x2F; linxin</span><br></pre></td></tr></table></figure>
bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。</li>
<li>参数的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function func(a, b, c) &#123;</span><br><span class="line">    console.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">var func1 &#x3D; func.bind(null,&#39;linxin&#39;);</span><br><span class="line"></span><br><span class="line">func(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);            &#x2F;&#x2F; A B C</span><br><span class="line">func1(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);           &#x2F;&#x2F; linxin A B</span><br><span class="line">func1(&#39;B&#39;, &#39;C&#39;);                &#x2F;&#x2F; linxin B C</span><br><span class="line">func.call(null, &#39;linxin&#39;);      &#x2F;&#x2F; linxin undefined undefined</span><br></pre></td></tr></table></figure>
call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/01/19/value/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MJLUCY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MJbLog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/19/value/" itemprop="url">原始类型与引用类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-19T00:00:00+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>原始类型也称为基本类型或简单类型，javascript基本数据类型包括Undefined、Null、Boolean、Number和String五种。<br>原始值明显的特征是不可更改，任何方法都无法更改一个原始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s&#x3D; &#39;hello&#39;;</span><br><span class="line">s.toUpperCase();</span><br><span class="line">console.log(s);&#x2F;&#x2F;&#39;hello&#39;</span><br></pre></td></tr></table></figure>
<p>而引用类型也称为复杂类型，在javascript中是Object<br>复杂值可以由很多不同类型的javascript对象组成。复杂对象其在内存中的大小是未知的，因为复杂对象可以包含任何值，而不是一个特定的已知值</p>
<p>对象和原始值不同，它们是可变的，它们的值是可修改的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;x:1&#125;;</span><br><span class="line">o.x &#x3D; 2;</span><br><span class="line">o.y &#x3D; 3;</span><br></pre></td></tr></table></figure>

<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>栈存储</strong><br>　　因为原始值占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中</p>
<p><strong>堆存储</strong><br>　　由于复杂值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处</p>
<p><img src="/images/pic7.jpg" alt="图片7"></p>
<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><p>按值访问<br>　　原始值是作为不可细化的值进行存储和操作的，引用它们会转移其值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myString &#x3D; &#39;foo&#39;;</span><br><span class="line">var myStringCopy &#x3D; myString;</span><br><span class="line">var myString &#x3D; null;</span><br><span class="line">console.log(myString,myStringCopy);&#x2F;&#x2F;null,&#39;foo&#39;</span><br></pre></td></tr></table></figure>
<p>引用访问<br>　　复杂值是通过引用进行存储和操作的，而不是实际的值。创建一个包含复杂对象的变量时，其值是内存中的一个引用地址。引用一个复杂对象时，使用它的名称(即变量或对象属性)通过内存中的引用地址获取该对象值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObject &#x3D; &#123;&#125;;</span><br><span class="line">var copyOfMyObject &#x3D; myObject;&#x2F;&#x2F;没有复制值，而是复制了引用</span><br><span class="line">myObject.foo &#x3D; &#39;bar&#39;;&#x2F;&#x2F;操作myObject中的值</span><br><span class="line">&#x2F;&#x2F;现在如果输出myObject和copyOfMyObject，则都会输出foo属性，因为它们引用的是同一个对象</span><br><span class="line">console.log(myObject,copyOfMyObject);&#x2F;&#x2F;Object&#123;foo&#x3D;&quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较方式"><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h3><p>原始值采用值比较，而复杂值采用引用比较。复杂值只有在引用相同的对象(即有相同的地址)时才相等。</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>对于复杂值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但简单值不可以添加属性和方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">MJLUCY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MJLUCY</span>

  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
